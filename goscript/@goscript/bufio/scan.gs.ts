import * as $ from "@goscript/builtin/index.js";
import { Reader } from "./bufio.gs.js";

import * as bytes from "@goscript/bytes/index.js"

import * as errors from "@goscript/errors/index.js"

import * as io from "@goscript/io/index.js"

import * as utf8 from "@goscript/unicode/utf8/index.js"

// MaxScanTokenSize is the maximum size used to buffer a token
// unless the user provides an explicit buffer with [Scanner.Buffer].
// The actual maximum token size may be smaller as the buffer
// may need to include, for instance, a newline.
export let MaxScanTokenSize: number = 64 * 1024

// Size of initial allocation for buffer.
let startBufSize: number = 4096

export type SplitFunc = ((data: $.Bytes, atEOF: boolean) => [number, $.Bytes, $.GoError]) | null;

export class Scanner {
	// The reader provided by the client.
	public get r(): io.Reader {
		return this._fields.r.value
	}
	public set r(value: io.Reader) {
		this._fields.r.value = value
	}

	// The function to split the tokens.
	public get split(): SplitFunc | null {
		return this._fields.split.value
	}
	public set split(value: SplitFunc | null) {
		this._fields.split.value = value
	}

	// Maximum size of a token; modified by tests.
	public get maxTokenSize(): number {
		return this._fields.maxTokenSize.value
	}
	public set maxTokenSize(value: number) {
		this._fields.maxTokenSize.value = value
	}

	// Last token returned by split.
	public get token(): $.Bytes {
		return this._fields.token.value
	}
	public set token(value: $.Bytes) {
		this._fields.token.value = value
	}

	// Buffer used as argument to split.
	public get buf(): $.Bytes {
		return this._fields.buf.value
	}
	public set buf(value: $.Bytes) {
		this._fields.buf.value = value
	}

	// First non-processed byte in buf.
	public get start(): number {
		return this._fields.start.value
	}
	public set start(value: number) {
		this._fields.start.value = value
	}

	// End of data in buf.
	public get end(): number {
		return this._fields.end.value
	}
	public set end(value: number) {
		this._fields.end.value = value
	}

	// Sticky error.
	public get err(): $.GoError {
		return this._fields.err.value
	}
	public set err(value: $.GoError) {
		this._fields.err.value = value
	}

	// Count of successive empty tokens.
	public get empties(): number {
		return this._fields.empties.value
	}
	public set empties(value: number) {
		this._fields.empties.value = value
	}

	// Scan has been called; buffer is in use.
	public get scanCalled(): boolean {
		return this._fields.scanCalled.value
	}
	public set scanCalled(value: boolean) {
		this._fields.scanCalled.value = value
	}

	// Scan has finished.
	public get done(): boolean {
		return this._fields.done.value
	}
	public set done(value: boolean) {
		this._fields.done.value = value
	}

	public _fields: {
		r: $.VarRef<io.Reader>;
		split: $.VarRef<SplitFunc | null>;
		maxTokenSize: $.VarRef<number>;
		token: $.VarRef<$.Bytes>;
		buf: $.VarRef<$.Bytes>;
		start: $.VarRef<number>;
		end: $.VarRef<number>;
		err: $.VarRef<$.GoError>;
		empties: $.VarRef<number>;
		scanCalled: $.VarRef<boolean>;
		done: $.VarRef<boolean>;
	}

	constructor(init?: Partial<{buf?: $.Bytes, done?: boolean, empties?: number, end?: number, err?: $.GoError, maxTokenSize?: number, r?: io.Reader, scanCalled?: boolean, split?: SplitFunc | null, start?: number, token?: $.Bytes}>) {
		this._fields = {
			r: $.varRef(init?.r ?? null),
			split: $.varRef(init?.split ?? new SplitFunc | null(null)),
			maxTokenSize: $.varRef(init?.maxTokenSize ?? 0),
			token: $.varRef(init?.token ?? new Uint8Array(0)),
			buf: $.varRef(init?.buf ?? new Uint8Array(0)),
			start: $.varRef(init?.start ?? 0),
			end: $.varRef(init?.end ?? 0),
			err: $.varRef(init?.err ?? null),
			empties: $.varRef(init?.empties ?? 0),
			scanCalled: $.varRef(init?.scanCalled ?? false),
			done: $.varRef(init?.done ?? false)
		}
	}

	public clone(): Scanner {
		const cloned = new Scanner()
		cloned._fields = {
			r: $.varRef(this._fields.r.value),
			split: $.varRef(this._fields.split.value),
			maxTokenSize: $.varRef(this._fields.maxTokenSize.value),
			token: $.varRef(this._fields.token.value),
			buf: $.varRef(this._fields.buf.value),
			start: $.varRef(this._fields.start.value),
			end: $.varRef(this._fields.end.value),
			err: $.varRef(this._fields.err.value),
			empties: $.varRef(this._fields.empties.value),
			scanCalled: $.varRef(this._fields.scanCalled.value),
			done: $.varRef(this._fields.done.value)
		}
		return cloned
	}

	// Err returns the first non-EOF error that was encountered by the [Scanner].
	public Err(): $.GoError {
		const s = this
		if (s.err == io.EOF) {
			return null
		}
		return s.err
	}

	// Bytes returns the most recent token generated by a call to [Scanner.Scan].
	// The underlying array may point to data that will be overwritten
	// by a subsequent call to Scan. It does no allocation.
	public Bytes(): $.Bytes {
		const s = this
		return s.token
	}

	// Text returns the most recent token generated by a call to [Scanner.Scan]
	// as a newly allocated string holding its bytes.
	public Text(): string {
		const s = this
		return $.bytesToString(s.token)
	}

	// Scan advances the [Scanner] to the next token, which will then be
	// available through the [Scanner.Bytes] or [Scanner.Text] method. It returns false when
	// there are no more tokens, either by reaching the end of the input or an error.
	// After Scan returns false, the [Scanner.Err] method will return any error that
	// occurred during scanning, except that if it was [io.EOF], [Scanner.Err]
	// will return nil.
	// Scan panics if the split function returns too many empty
	// tokens without advancing the input. This is a common error mode for
	// scanners.
	public Scan(): boolean {
		const s = this
		if (s.done) {
			return false
		}
		s.scanCalled = true
		for (; ; ) {
			// See if we can get a token with what we already have.
			// If we've run out of data but have an error, give the split function
			// a chance to recover any remaining, possibly empty token.

			// When token is not nil, it means the scanning stops
			// with a trailing token, and thus the return value
			// should be true to indicate the existence of the token.

			// Returning tokens not advancing input at EOF.
			if (s.end > s.start || s.err != null) {
				let [advance, token, err] = s.split!($.goSlice(s.buf, s.start, s.end), s.err != null)

				// When token is not nil, it means the scanning stops
				// with a trailing token, and thus the return value
				// should be true to indicate the existence of the token.
				if (err != null) {

					// When token is not nil, it means the scanning stops
					// with a trailing token, and thus the return value
					// should be true to indicate the existence of the token.
					if (err == ErrFinalToken) {
						s.token = token
						s.done = true
						// When token is not nil, it means the scanning stops
						// with a trailing token, and thus the return value
						// should be true to indicate the existence of the token.
						return token != null
					}
					s.setErr(err)
					return false
				}
				if (!s.advance(advance)) {
					return false
				}
				s.token = token

				// Returning tokens not advancing input at EOF.
				if (token != null) {

					// Returning tokens not advancing input at EOF.
					if (s.err == null || advance > 0) {
						s.empties = 0
					}
					 else {
						// Returning tokens not advancing input at EOF.
						s.empties++
						if (s.empties > 100) {
							$.panic("bufio.Scan: too many empty tokens without progressing")
						}
					}
					return true
				}
			}
			// We cannot generate a token with what we are holding.
			// If we've already hit EOF or an I/O error, we are done.

			// Shut it down.
			if (s.err != null) {
				// Shut it down.
				s.start = 0
				s.end = 0
				return false
			}
			// Must read more data.
			// First, shift data to beginning of buffer if there's lots of empty space
			// or space is needed.
			if (s.start > 0 && (s.end == $.len(s.buf) || s.start > $.len(s.buf) / 2)) {
				$.copy(s.buf, $.goSlice(s.buf, s.start, s.end))
				s.end -= s.start
				s.start = 0
			}
			// Is the buffer full? If so, resize.

			// Guarantee no overflow in the multiplication below.
			if (s.end == $.len(s.buf)) {
				// Guarantee no overflow in the multiplication below.
				let maxInt: number = $.int((~(0 as number) >> 1))
				if ($.len(s.buf) >= s.maxTokenSize || $.len(s.buf) > 9223372036854775807 / 2) {
					s.setErr(ErrTooLong)
					return false
				}
				let newSize = $.len(s.buf) * 2
				if (newSize == 0) {
					newSize = 4096
				}
				newSize = min(newSize, s.maxTokenSize)
				let newBuf = new Uint8Array(newSize)
				$.copy(newBuf, $.goSlice(s.buf, s.start, s.end))
				s.buf = newBuf
				s.end -= s.start
				s.start = 0
			}
			// Finally we can read some input. Make sure we don't get stuck with
			// a misbehaving Reader. Officially we don't need to do this, but let's
			// be extra careful: Scanner is for safe, simple jobs.
			for (let loop = 0; ; ) {
				let [n, err] = s.r!.Read($.goSlice(s.buf, s.end, $.len(s.buf)))
				if (n < 0 || $.len(s.buf) - s.end < n) {
					s.setErr(ErrBadReadCount)
					break
				}
				s.end += n
				if (err != null) {
					s.setErr(err)
					break
				}
				if (n > 0) {
					s.empties = 0
					break
				}
				loop++
				if (loop > 100) {
					s.setErr(io.ErrNoProgress)
					break
				}
			}
		}
	}

	// advance consumes n bytes of the buffer. It reports whether the advance was legal.
	public advance(n: number): boolean {
		const s = this
		if (n < 0) {
			s.setErr(ErrNegativeAdvance)
			return false
		}
		if (n > s.end - s.start) {
			s.setErr(ErrAdvanceTooFar)
			return false
		}
		s.start += n
		return true
	}

	// setErr records the first error encountered.
	public setErr(err: $.GoError): void {
		const s = this
		if (s.err == null || s.err == io.EOF) {
			s.err = err
		}
	}

	// Buffer sets the initial buffer to use when scanning
	// and the maximum size of buffer that may be allocated during scanning.
	// The maximum token size must be less than the larger of max and cap(buf).
	// If max <= cap(buf), [Scanner.Scan] will use this buffer only and do no allocation.
	//
	// By default, [Scanner.Scan] uses an internal buffer and sets the
	// maximum token size to [MaxScanTokenSize].
	//
	// Buffer panics if it is called after scanning has started.
	public Buffer(buf: $.Bytes, max: number): void {
		const s = this
		if (s.scanCalled) {
			$.panic("Buffer called after Scan")
		}
		s.buf = $.goSlice(buf, 0, $.cap(buf))
		s.maxTokenSize = max
	}

	// Split sets the split function for the [Scanner].
	// The default split function is [ScanLines].
	//
	// Split panics if it is called after scanning has started.
	public Split(split: SplitFunc | null): void {
		const s = this
		if (s.scanCalled) {
			$.panic("Split called after Scan")
		}
		s.split = split
	}

	// Register this type with the runtime type system
	static __typeInfo = $.registerStructType(
	  'Scanner',
	  new Scanner(),
	  [{ name: "Err", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: "Bytes", args: [], returns: [{ type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: "number" } } }] }, { name: "Text", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: "string" } }] }, { name: "Scan", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: "boolean" } }] }, { name: "advance", args: [{ name: "n", type: { kind: $.TypeKind.Basic, name: "number" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: "boolean" } }] }, { name: "setErr", args: [{ name: "err", type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }], returns: [] }, { name: "Buffer", args: [{ name: "buf", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: "number" } } }, { name: "max", type: { kind: $.TypeKind.Basic, name: "number" } }], returns: [] }, { name: "Split", args: [{ name: "split", type: "SplitFunc" }], returns: [] }],
	  Scanner,
	  {"r": "Reader", "split": "SplitFunc", "maxTokenSize": { kind: $.TypeKind.Basic, name: "number" }, "token": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: "number" } }, "buf": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: "number" } }, "start": { kind: $.TypeKind.Basic, name: "number" }, "end": { kind: $.TypeKind.Basic, name: "number" }, "err": { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] }, "empties": { kind: $.TypeKind.Basic, name: "number" }, "scanCalled": { kind: $.TypeKind.Basic, name: "boolean" }, "done": { kind: $.TypeKind.Basic, name: "boolean" }}
	);
}

export let ErrAdvanceTooFar: $.GoError = errors.New("bufio.Scanner: SplitFunc returns advance count beyond input")

export let ErrBadReadCount: $.GoError = errors.New("bufio.Scanner: Read returned impossible count")

export let ErrFinalToken: $.GoError = errors.New("final token")

export let ErrNegativeAdvance: $.GoError = errors.New("bufio.Scanner: SplitFunc returns negative advance count")

export let ErrTooLong: $.GoError = errors.New("bufio.Scanner: token too long")

let errorRune: $.Bytes = $.stringToBytes($.runeOrStringToString(utf8.RuneError))

// NewScanner returns a new [Scanner] to read from r.
// The split function defaults to [ScanLines].
export function NewScanner(r: io.Reader): Scanner | null {
	return new Scanner({maxTokenSize: 65536, r: r, split: ScanLines})
}

// ScanBytes is a split function for a [Scanner] that returns each byte as a token.
export function ScanBytes(data: $.Bytes, atEOF: boolean): [number, $.Bytes, $.GoError] {
	let advance: number = 0
	let token: $.Bytes = new Uint8Array(0)
	let err: $.GoError = null
	{
		if (atEOF && $.len(data) == 0) {
			return [0, null, null]
		}
		return [1, $.goSlice(data, 0, 1), null]
	}
}

// ScanRunes is a split function for a [Scanner] that returns each
// UTF-8-encoded rune as a token. The sequence of runes returned is
// equivalent to that from a range loop over the input as a string, which
// means that erroneous UTF-8 encodings translate to U+FFFD = "\xef\xbf\xbd".
// Because of the Scan interface, this makes it impossible for the client to
// distinguish correctly encoded replacement runes from encoding errors.
export function ScanRunes(data: $.Bytes, atEOF: boolean): [number, $.Bytes, $.GoError] {
	let advance: number = 0
	let token: $.Bytes = new Uint8Array(0)
	let err: $.GoError = null
	{
		if (atEOF && $.len(data) == 0) {
			return [0, null, null]
		}

		// Fast path 1: ASCII.
		if (data![0] < utf8.RuneSelf) {
			return [1, $.goSlice(data, 0, 1), null]
		}

		// Fast path 2: Correct UTF-8 decode without error.
		let [, width] = utf8.DecodeRune(data)

		// It's a valid encoding. Width cannot be one for a correctly encoded
		// non-ASCII rune.
		if (width > 1) {
			// It's a valid encoding. Width cannot be one for a correctly encoded
			// non-ASCII rune.
			return [width, $.goSlice(data, 0, width), null]
		}

		// We know it's an error: we have width==1 and implicitly r==utf8.RuneError.
		// Is the error because there wasn't a full rune to be decoded?
		// FullRune distinguishes correctly between erroneous and incomplete encodings.

		// Incomplete; get more bytes.
		if (!atEOF && !utf8.FullRune(data)) {
			// Incomplete; get more bytes.
			return [0, null, null]
		}

		// We have a real UTF-8 encoding error. Return a properly encoded error rune
		// but advance only one byte. This matches the behavior of a range loop over
		// an incorrectly encoded string.
		return [1, errorRune, null]
	}
}

// dropCR drops a terminal \r from the data.
export function dropCR(data: $.Bytes): $.Bytes {
	if ($.len(data) > 0 && data![$.len(data) - 1] == 13) {
		return $.goSlice(data, 0, $.len(data) - 1)
	}
	return data
}

// ScanLines is a split function for a [Scanner] that returns each line of
// text, stripped of any trailing end-of-line marker. The returned line may
// be empty. The end-of-line marker is one optional carriage return followed
// by one mandatory newline. In regular expression notation, it is `\r?\n`.
// The last non-empty line of input will be returned even if it has no
// newline.
export function ScanLines(data: $.Bytes, atEOF: boolean): [number, $.Bytes, $.GoError] {
	let advance: number = 0
	let token: $.Bytes = new Uint8Array(0)
	let err: $.GoError = null
	{
		if (atEOF && $.len(data) == 0) {
			return [0, null, null]
		}

		// We have a full newline-terminated line.
		{
			let i = bytes.IndexByte(data, 10)
			if (i >= 0) {
				// We have a full newline-terminated line.
				return [i + 1, dropCR($.goSlice(data, 0, i)), null]
			}
		}
		// If we're at EOF, we have a final, non-terminated line. Return it.
		if (atEOF) {
			return [$.len(data), dropCR(data), null]
		}
		// Request more data.
		return [0, null, null]
	}
}

// isSpace reports whether the character is a Unicode white space character.
// We avoid dependency on the unicode package, but check validity of the implementation
// in the tests.
export function isSpace(r: number): boolean {

	// Obvious ASCII ones: \t through \r plus space. Plus two Latin-1 oddballs.
	if (r <= 255) {
		// Obvious ASCII ones: \t through \r plus space. Plus two Latin-1 oddballs.
		switch (r) {
			case 32:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
				return true
				break
			case 133:
			case 160:
				return true
				break
		}
		return false
	}
	// High-valued ones.
	if (8192 <= r && r <= 8202) {
		return true
	}
	switch (r) {
		case 5760:
		case 8232:
		case 8233:
		case 8239:
		case 8287:
		case 12288:
			return true
			break
	}
	return false
}

// ScanWords is a split function for a [Scanner] that returns each
// space-separated word of text, with surrounding spaces deleted. It will
// never return an empty string. The definition of space is set by
// unicode.IsSpace.
export function ScanWords(data: $.Bytes, atEOF: boolean): [number, $.Bytes, $.GoError] {
	let advance: number = 0
	let token: $.Bytes = new Uint8Array(0)
	let err: $.GoError = null
	{
		// Skip leading spaces.
		let start = 0
		for (let width = 0; start < $.len(data); start += width) {
			let r: number = 0
			;[r, width] = utf8.DecodeRune($.goSlice(data, start, undefined))
			if (!isSpace(r)) {
				break
			}
		}
		// Scan until space, marking end of word.
		for (let width = 0, i = start; i < $.len(data); i += width) {
			let r: number = 0
			;[r, width] = utf8.DecodeRune($.goSlice(data, i, undefined))
			if (isSpace(r)) {
				return [i + width, $.goSlice(data, start, i), null]
			}
		}
		// If we're at EOF, we have a final, non-empty, non-terminated word. Return it.
		if (atEOF && $.len(data) > start) {
			return [$.len(data), $.goSlice(data, start, undefined), null]
		}
		// Request more data.
		return [start, null, null]
	}
}

