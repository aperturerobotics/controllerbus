import * as $ from "@goscript/builtin/index.js";

import * as errors from "@goscript/errors/index.js"

import * as io from "@goscript/io/index.js"

export let MaxVarintLen16: number = 3

export let MaxVarintLen32: number = 5

export let MaxVarintLen64: number = 10

let errOverflow: $.GoError = errors.New("binary: varint overflows a 64-bit integer")

// AppendUvarint appends the varint-encoded form of x,
// as generated by [PutUvarint], to buf and returns the extended buffer.
export function AppendUvarint(buf: $.Bytes, x: number): $.Bytes {
	for (; x >= 0x80; ) {
		buf = $.append(buf, ($.byte(x) | 0x80))
		x >>= 7
	}
	return $.append(buf, $.byte(x))
}

// PutUvarint encodes a uint64 into buf and returns the number of bytes written.
// If the buffer is too small, PutUvarint will panic.
export function PutUvarint(buf: $.Bytes, x: number): number {
	let i = 0
	for (; x >= 0x80; ) {
		buf![i] = ($.byte(x) | 0x80)
		x >>= 7
		i++
	}
	buf![i] = $.byte(x)
	return i + 1
}

// Uvarint decodes a uint64 from buf and returns that value and the
// number of bytes read (> 0). If an error occurred, the value is 0
// and the number of bytes n is <= 0 meaning:
//   - n == 0: buf too small;
//   - n < 0: value larger than 64 bits (overflow) and -n is the number of
//     bytes read.
export function Uvarint(buf: $.Bytes): [number, number] {
	let x: number = 0
	let s: number = 0

	// Catch byte reads past MaxVarintLen64.
	// See issue https://golang.org/issues/41185
	// overflow

	// overflow
	for (let i = 0; i < $.len(buf); i++) {
		const b = buf![i]
		{

			// Catch byte reads past MaxVarintLen64.
			// See issue https://golang.org/issues/41185
			// overflow
			if (i == 10) {
				// Catch byte reads past MaxVarintLen64.
				// See issue https://golang.org/issues/41185
				return [0, -(i + 1)]
			}

			// overflow
			if (b < 0x80) {

				// overflow
				if (i == 10 - 1 && b > 1) {
					return [0, -(i + 1)]
				}
				return [(x | ((b as number) << s)), i + 1]
			}
			x |= (((b & 0x7f) as number) << s)
			s += 7
		}
	}
	return [0, 0]
}

// AppendVarint appends the varint-encoded form of x,
// as generated by [PutVarint], to buf and returns the extended buffer.
export function AppendVarint(buf: $.Bytes, x: number): $.Bytes {
	let ux = ((x as number) << 1)
	if (x < 0) {
		ux = ~ux
	}
	return AppendUvarint(buf, ux)
}

// PutVarint encodes an int64 into buf and returns the number of bytes written.
// If the buffer is too small, PutVarint will panic.
export function PutVarint(buf: $.Bytes, x: number): number {
	let ux = ((x as number) << 1)
	if (x < 0) {
		ux = ~ux
	}
	return PutUvarint(buf, ux)
}

// Varint decodes an int64 from buf and returns that value and the
// number of bytes read (> 0). If an error occurred, the value is 0
// and the number of bytes n is <= 0 with the following meaning:
//   - n == 0: buf too small;
//   - n < 0: value larger than 64 bits (overflow)
//     and -n is the number of bytes read.
export function Varint(buf: $.Bytes): [number, number] {
	let [ux, n] = Uvarint(buf)
	let x = ((ux >> 1) as number)
	if ((ux & 1) != 0) {
		x = ~x
	}
	return [x, n]
}

// ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.
// The error is [io.EOF] only if no bytes were read.
// If an [io.EOF] happens after reading some but not all the bytes,
// ReadUvarint returns [io.ErrUnexpectedEOF].
export function ReadUvarint(r: io.ByteReader): [number, $.GoError] {
	let x: number = 0
	let s: number = 0
	for (let i = 0; i < 10; i++) {
		let [b, err] = r!.ReadByte()
		if (err != null) {
			if (i > 0 && err == io.EOF) {
				err = io.ErrUnexpectedEOF
			}
			return [x, err]
		}
		if (b < 0x80) {
			if (i == 10 - 1 && b > 1) {
				return [x, errOverflow]
			}
			return [(x | ((b as number) << s)), null]
		}
		x |= (((b & 0x7f) as number) << s)
		s += 7
	}
	return [x, errOverflow]
}

// ReadVarint reads an encoded signed integer from r and returns it as an int64.
// The error is [io.EOF] only if no bytes were read.
// If an [io.EOF] happens after reading some but not all the bytes,
// ReadVarint returns [io.ErrUnexpectedEOF].
export function ReadVarint(r: io.ByteReader): [number, $.GoError] {
	let [ux, err] = ReadUvarint(r)
	let x = ((ux >> 1) as number)
	if ((ux & 1) != 0) {
		x = ~x
	}
	return [x, err]
}

